#' Calculate the mixing diagram to illustrate the co-evolution of potential temperature and humidity during a entire day process.
#' @param sp a numeric vector or 3D array of surface pressure [Pa]
#' @param t2m a numeric vector or 3D array of 2m temperature [K]
#' @param q2m a numeric vector or 3D array of 2m specific humidity [kg.kg-1]
#' @param shf a numeric vector or 3D array of upward sensible heat flux [W.m-2]
#' @param lhf a numeric vector or 3D array of upward latent heat flux [W.m-2]
#' @param hbpl a numeric vector or 3D array of planetary boundary layer height [m]
#' @param time information. It can be either in PCICt format (e.g.,
#' "1980-01-01 10:50:33") or in numeric format (hours, e.g., 12, 12.5, etc).
#' If the numeric format is applied, there will no daytime information
#' generated.
#' @param time.type whether the time is LST or UTC (default).
#' @param lon if the time is UTC
#' @return a list containing the evolution of humidity and temperature at a entire day circle
#' @export
#mixing_diagram  <-  function(lons,lats,sp,t2m,q2m,hpbl,time,time.type='UTC'){
#    #check inputs types
#    t.sp    <-  loco_check_type(sp)
#    t.t2m   <-  loco_check_type(t2m)
#    t.q2m   <-  loco_check_type(q2m)
#    t.hpbl  <-  loco_check_type(hpbl)
#
#    #check inputs types
#    if (!(t.sp$t == 'n')    |
#        !(t.t2m$t == 'n')   |
#        !(t.q2m$t == 'n')   |
#        !(t.hpbl$t == 'n'))
#            stop('mixing_diagram: all inputs must be numeric')
#
#    #check if the dimensions of these inputs are the same
#    if (!all(t.sp$d == t.t2m$d,
#             t.t2m$d == t.q2m$d,
#             t.t2m$d == t.hpbl$d))
#        stop('mixing_diagram: dimensions of inputs are mismatch.')
#
#    #1-D time series
#    if (length(t.sp$d) == 1)
#    {
#    } else if (length(t.sp$d) == 3)
#    {
#    } else #3D [lon,lat,time]
#        stop('mixing_diagram: inputs dimension must be 1D [time] or 3D [lon,lat,time].')
#
#    return(mdiag.o)
#}

# This function calculate mixing diagram for one grid cell and provide simple diagnostic summary
mixing_diagram  <-  function(sp,t2m,q2m,shf,lhf,hpbl,times,lon=NULL,lat=NULL,time.type='UTC',day.lst=NULL){
    Lv  <-  2.5e6
    cp  <-  1005.7
    Rd  <-  287.04
    ep  <-  .622
    n.t <-  length(sp)
    dt  <-  as.numeric(times[2] - times[1])

    if (time.type == 'UTC')
    {
        time.utc    <-  times
        time.lst    <-  UTC2LST(time.utc,lon)
    } else if (time.type == 'LST')
    {
        time.lst    <-  times
        time.utc    <-  LST2UTC(time.utc,lon)
    } else
        stop('mixing_diagram: the time format cannot be recognized.')

    #key outputs
    cp.t    <-  cp*t2m
    lv.q    <-  Lv*q2m
    rho <-  sp/(Rd*t2m*(1+q2m/ep)/(1+q2m))
    f.sfc.ts <-  shf*dt/(rho*hpbl)
    m.sfc.ts <-  lhf*dt/(rho*hpbl)


    if (class(times[1]) == "PCICt")
    #calculate sunrise and sunset
    {

        dates.lst   <- format(time.lst,"%Y-%m-%d")
        days.lst   <- unique(dates.lst)
        days.utc   <- unique(format(time.utc,"%Y-%m-%d"))
        num.day   <-  length(days.utc)
        idx.day <-  array(NA,dim=n.t)
        f.sfc   <-  array(NA,dim=num.day)
        m.sfc   <-  array(NA,dim=num.day)
        f.atm   <-  array(NA,dim=num.day)
        m.atm   <-  array(NA,dim=num.day)


        for (i.d in 1:num.day)
        {
           idd.t   <-  seq(1,n.t)[dates.lst == days.utc[i.d]]
           n.d.t   <-  length(idd.t)
           if (n.d.t == 0) #not contain certain days
            next

           idx.day[idd.t]   <-  i.d
           sun.rs  <- GetSunRiseSet(as.Date(days.utc[i.d]),lon,lat)
           if (class(sun.rs[1]) == 'PCICt') #not polar day or night
           {
               id.night<-  idd.t[GetTimeNum(time.lst[idd.t]) <=
                                 GetTimeNum(sun.rs[1]) |
                                 GetTimeNum(time.lst[idd.t]) >=
                                 GetTimeNum(sun.rs[2])]
               id.day  <-  idd.t[GetTimeNum(time.lst[idd.t]) >
                                 GetTimeNum(sun.rs[1]) &
                                 GetTimeNum(time.lst[idd.t]) <
                                 GetTimeNum(sun.rs[2])]
               idx.day[id.day]     <-  i.d
               idx.day[id.night]   <-  -i.d
               f.sfc[i.d]  <-  sum(f.sfc.ts[id.day])
               m.sfc[i.d]  <-  sum(m.sfc.ts[id.day])
               f.atm[i.d]  <-  sum(cp*(t2m[i.d+1] - t2m[i.d])[1:(length(i.d)-1)]) - f.sfc[i.d]
               m.atm[i.d]  <-  sum(cp*(q2m[i.d+1] - q2m[i.d])[1:(length(i.d)-1)]) - m.sfc[i.d]
           } else
           {
               idx.day[idd.t]  <-  sun.rs*i.d
           }
           idx.day[is.na(idx.day)]  <-  0
        }
        #determine the daytime
    } else if (class(mean(times)) == "numeric")
    #the input hours is in numeric format (e.g., 1,2,3,...)
    {
        stop('mixing_diagram: this format is not supported currently.')
        if (is.null(day.lst))
        warning("mixing_diagram: no specific daytime information. The sun rise and sun set time are set to 6am and 6pm LST.")
        sun.rs  <-  c(6,18)
    } else
        stop('mixing_diagram: Time format is unacceptable.')

    #get the index of daytime starts and ends
    mdiag.o <-  list(cpt=cp.t,lvq=lv.q,f.sfc=f.sfc,
                     m.sfc=m.sfc,f.atm=f.atm,sp=sp,
                     m.atm=m.atm,times=time.lst,idx.day=idx.day)
    class(mdiag.o)  <-  'hmdiag1d'
    return(mdiag.o)
}

#' @export
plot_mdiag_1d   <-  function(mdiag,id.day,day.only=T,rh=F,...){
    Lv  <-  2.5e6
    cp  <-  1005.7
    if (is.numeric(id.day))
    {
        n.t <-  length(mdiag$cpt)
        id.t    <-  seq(1,n.t)[abs(mdiag$idx.day) == id.day]
        id.dn   <-  mdiag$idx.day[id.t]
        cp.t    <-  mdiag$cpt[id.t]
        lv.t    <-  mdiag$lvq[id.t]
        sp.t    <-  mdiag$sp[id.t]
        f.sfc   <-  mdiag$f.sfc[id.day]
        m.sfc   <-  mdiag$m.sfc[id.day]
        f.atm   <-  mdiag$atm[id.day]
        m.atm   <-  mdiag$atm[id.day]
        hrs.t   <-  format(mdiag$times[id.t],'%H:%M')
        
        sp.m    <-  mean(sp.t)

        col.night   <-  1
        col.day <-  2

        if (day.only)
        {
        plot(lv.t[id.dn >0],cp.t[id.dn > 0],type='l',
             ylab=expression('2-m Temperature ('*L[v]*q*' [J/kg])'),
             xlab=expression('2-m Humidity ('*C[p]*K*'[J/kg])'),
                             col=col.night)
        text((lv.t[id.dn > 0])[1],(cp.t[id.dn > 0])[1],
             labels=(hrs.t[id.dn > 0])[1])
        len.dnd <-  length(cp.t[id.dn > 0])
        text((lv.t[id.dn > 0])[len.dnd],(cp.t[id.dn > 0])[len.dnd],
             labels=(hrs.t[id.dn > 0])[len.dnd])
        } else
        {
        plot(lv.t,cp.t,type='l',
             ylab=expression('2-m Temperature ('*L[v]*q*' [J/kg])'),
             xlab=expression('2-m Humidity ('*C[p]*K*'[J/kg])'),
             col=col.night)
        lines(lv.t[id.dn > 0], cp.t[id.dn > 0],col=col.day)
        text((lv.t[id.dn > 0])[1],(cp.t[id.dn > 0])[1],
             labels=(hrs.t[id.dn > 0])[1])
        len.dnd <-  length(cp.t[id.dn > 0])
        text((lv.t[id.dn > 0])[len.dnd],(cp.t[id.dn > 0])[len.dnd],
             labels=(hrs.t[id.dn > 0])[len.dnd])
        }

    } else if (class(id.day) == 'PCICt')
    {
    } else
        stop('plot_mdiag_1d: the day index cannot be recognized.')

    if (rh)
    {
        xx  <-  seq(min(lv.t),max(lv.t),length.out=100)
        yy  <-  seq(min(cp.t),max(cp.t),length.out=100)
        mat <-  outer(xx,yy,
                      Vectorize(function(x,y) SH2RH(x/Lv,y/cp,sp.m)))
        contour(xx,yy,mat,add=T,levels=seq(0,100,10),col='grey')
        #for (i in seq(0,100,10))
        #{
        #    curve(t_contour(x,i,sp.m),add=T,col='gray',lty=2)
        #}

    }
}


t_contour  <-  function(lv.i,rh.i,p.i){
    cp  <-  1005.7
    Lv  <-  2.5e6
    L   <-  2.5e6
    Rw  <-  461.52
    T0  <-  273.15
    Es.T0   <-  6.11
    q2m.t   <-  lv.i/Lv

    med.t   <-  q2m.t*(p.i)/(rh.i*(.622+.378*q2m.t))

    t.o <-  1/(1/T0 - log(med.t/Es.T0)*Rw/L)

    return(t.o*cp)
}
